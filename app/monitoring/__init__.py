# ──────────────────────────────────────────────────────────────────────────────
# LPR v2 — модульная архитектура (RTSP/ONVIF, мультипроцессинг, гибкие маски)
# ──────────────────────────────────────────────────────────────────────────────
# Структура файлов (в этом документе — все части подряд):
#
# app/monitoring/
# ├─ __init__.py
# ├─ config_runtime.py # runtime-настройки + выбор GPU/CPU
# ├─ onvif_client.py # получение RTSP через ONVIF (необязательно)
# ├─ capture/rtsp_capture.py # захват кадров (процесс)
# ├─ roi/masks.py # загрузка, нормализация и применение масок ROI
# ├─ detection/plate_detector.py # детектор номерных знаков (Haar/ONNX YOLO)
# ├─ recognition/ocr_recognizer.py# OCR (PaddleOCR или EasyOCR как fallback)
# ├─ utils/regexes.py # проверка форматов номеров (RU и др.)
# ├─ pipeline.py # конвейер: Capture → Detect → OCR → Validate
# └─ run_monitor.py # CLI-запуск для разных камер/ресиверов
#
# Доп. файлы:
# config/cameras.yaml # гибкая конфигурация камер, масок, провайдеров
# models/plate_yolov5s.onnx # пример ONNX-детектора (поместить отдельно)
# ──────────────────────────────────────────────────────────────────────────────

# ──────────────────────────────────────────────────────────────────────────────
# Пояснения по выбору технологий и оптимизации
# ──────────────────────────────────────────────────────────────────────────────
# 1) Детектор: вместо Haar лучше ONNX-модель (YOLO-подобная), запускаем через onnxruntime
#    c CUDAExecutionProvider — быстро на 1080/3050. Можно и CPU, но медленнее.
#    Модель возьми натренированную на CCPD/аналогах (yolov5/v8-n лиценз. пластины) и экспортируй в ONNX.
#
# 2) OCR: PaddleOCR даёт лучшую точность по кириллице, чем EasyOCR. EasyOCR оставлен как fallback.
#    На GPU (use_gpu=True) — быстрее; на CPU тоже ок при нескольких воркерах.
#
# 3) Мультипроцессинг: захват кадров — отдельный процесс. OCR — пул процессов (2–4).
#    Детекция в основном процессе (или вынеси тоже в процесс, если будет узким местом).
#    Очереди ограничены по размеру; при переполнении выбрасываем старое (минимум задержки).
#
# 4) Маски: вынесены в YAML; у каждой камеры свой crop + polygon. Легко добавлять новые камеры.
#
# 5) ONVIF: при необходимости автоматически получить RTSP, не прописывая руками.
#
# 6) Предобработка под OCR: CLAHE + bilateral/или адаптивный трешхолд. Снимает проблему "EasyOCR ничего не видит".
#    Плюс нормализация латиница→кириллица и улучшенные регэкспы с регионом 2–3 цифры.
#
# 7) Гибкость GPU/CPU: через RuntimeOptions и ENV-переменные (LPR_DET_PROVIDER, LPR_OCR_PROVIDER, ...).
#
# 8) Расширение под другие объекты: добавь новый detector_*.py и новый ocr_* или "classifier_*" модуль;
#    pipeline останется тем же — просто ещё один этап после ROI.
#
# 9) Трекинг/стабилизация: при необходимости добавь ByteTrack/SORT и мажоритарное голосование по тексту.
#
# 10) RTSP стабильность: cv2.CAP_FFMPEG + CAP_PROP_BUFFERSIZE=1, стратегия drop-frames, 25 FPS.
#     Альтернатива: PyAV (av.open(...)) — иногда стабильнее.
#
# 11) Завершение: процессы демоны; при переводе в сервис — добавь ловлю сигналов SIGINT/SIGTERM.
#
# Зависимости (минимум):
#   pip install opencv-python-headless numpy onnxruntime-gpu paddleocr onvif-zeep pyyaml
#   # при CPU: onnxruntime вместо onnxruntime-gpu; для PaddleGPU нужен paddlepaddle-gpu подходящей версии
# ──────────────────────────────────────────────────────────────────────────────



# =============================== app/monitoring/__init__.py ===============================